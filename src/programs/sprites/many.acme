; Sprite demo
;
; Display several C64 balloons sprites and move them accros X.
;
; x position:
; SP0X bits #0-#7 sprite #0
; SP1X bits #0-#7 sprite #1
; ...
; MSIGX all sprites MSB

            ;ACME 0.97
            !cpu 6510

            !src <lib/registers/m_registers.acme>
            !src <lib/mmap/mmap.acme>
            !src <lib/mem/m_mem.acme>

            !src <lib/misc/upstart.acme>

            SPRITE_COUNT = 4
            SPRITE_AREA = $0340
            SPRITE_BLOCK = SPRITE_AREA / 64
            DELAY_16 = 255*2                ; busy wait delay

main:
            jsr init
            jmp animate                     ; JMP for endless


init:
            ; Clear screen
            jsr CINT

            ; Copy data to sprite block (same for all sprites)
            +copy_bytes_8 .sprite_data, SPRITE_AREA, 63

            ; Activate sprites
            lda #%00001111
            sta SPENA

            ; Initialiaze sprites
            ldx #0                          ; sprite index
            ldy #0                          ; sprites_init_pos index
-           jsr init_sprite
            inx                             ; next sprite
            cpx #SPRITE_COUNT
            bne -
            
            rts


init_sprite:
            ; Color
            lda .sprites_colors,x
            sta SP0COLOR,x

            ; Pointer area (block = 64 bytes) 
            lda #SPRITE_BLOCK
            sta DEFAULT_SPRITE_PTR_AREA,x

            ; Sprite position memory layout:
            ; SP0X, SP0Y, SP1X, SP1Y, ...
            ; Therefore Y is incremented by 2 for each sprite.
            lda .sprites_init_pos,y
            sta SP0X,y
            iny
            lda .sprites_init_pos,y
            sta SP0X,y
            iny

            rts


animate:
            lda >DELAY_16
            sta R5
            lda <DELAY_16
            sta R6                          ; busy wait params

--          ldx #SPRITE_COUNT
-           jsr move_sprite_x
            dex
            bne -
            jsr busy_wait
            jmp --


move_sprite_x:
            +push_ax

            dex                             ; X=n => sprite #(n-1)
            stx .sprite_idx

            ; Multiply sprite # by 2.
            ; Each sprite x pos register is previous + 2
            ; (#0 -> $d000, #1 -> $d002, ...).
            txa                             ; X <- X*2
            clc
            rol
            tax

            ; Move horizontally.
            ; Notice how we STX before BNE.
            ; This avoids a glitch when transitioning left/right.
            stx .x_lsb
            .x_lsb = *+1                    ; self mod x pos for pixel #X
            inc SP0X                        ; move right 1 pixel
            bne +

            ; Switch left/right by read-mod-write the x position.
            ; MSB register at $d010.
            ldx .sprite_idx
            lda .msb_x_pos_masks,x
            sta .x_msb_mask
            lda MSIGX                       ; read sprites x pos MSB register
            .x_msb_mask = *+1               ; self mod MSB
            eor #%00000000                  ; flip sprite #x MSB
            sta MSIGX                       ; update MSB register

+           +pull_xa
            rts


.sprite_idx:
            !byte 0
.sprites_colors:
            !byte 1, 7, 14, 10
.sprites_init_pos                           ; 7 bits only (x, y)
            !byte 15, 80
            !byte 70, 120
            !byte 45, 160
            !byte 200, 200
.msb_x_pos_masks:
            !byte 1, 2, 4, 8, 16, 32, 64, 128

.sprite_data:
            !bin <programs/sprites/balloon.bin>

            !src <lib/misc/busy_wait.acme>
