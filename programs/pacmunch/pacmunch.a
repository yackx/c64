; Pac-munch
;
; This crazy pacman will eat all characters on the screen.

            ;ACME 0.97
            !cpu 6510

            !src <lib/layout/main.a>
            !src <lib/screen/color.a>
            !src <lib/registers/pseudo-registers.a>

            !src <lib/misc/upstart.a>

            BITMAP_ADDR = $2000             ; Sprite bitmap address
            RASTER_LINE = 251               ; 251th line not visible on screen
            FRAME_SKIP = 1                  ; Skip frames each tick
            SPRITE_CYCLE_SKIP = 4           ; Move 4 pixels before animating sprite
            PACMAN_FRAMES = 4               ; Pacman is composed of 4 frames
            PIXELS_PER_CHAR = 8             ; Encounter one char every 8 pixels
            MUNCHED_CHAR = ' '              ; White space
            END_ROW = 240
            CURRENT_CHAR = R1


main:
            jsr print_msg
            jsr setup_sprites
            jsr setup_counters
            jsr munch
            rts


print_msg:
            lda #<msg
            sta R1
            lda #>msg
            sta R2
            jsr strout
            rts


setup_sprites:
            ldy #0
-           lda sprite, y
            sta BITMAP_ADDR, y              ; move sprite bitmaps
            iny
            bne -

            lda #$80
            sta DEFAULT_SPRITE_PTR_AREA     ; sprite #0 at $2000

            lda #0
            sta $d010                       ; sprite #0 8th bit x left part

            lda #0
            sta $d000
            lda #66
            sta $d001                       ; sprite #0: x=0, y=66

            lda #COLOR_YELLOW
            sta VIC2SPCOL0                  ; sprite #0 is yellow

            lda #1
            sta VIC2SPE                     ; enable sprite #0

            lda #<DEFAULT_SCREEN_MEM + 3*40 ; current char location
            sta CURRENT_CHAR                ; is the first col of 3rd row
            lda #>DEFAULT_SCREEN_MEM + 3*40
            sta CURRENT_CHAR + 1


setup_counters:
            ldx #SPRITE_CYCLE_SKIP          ; init sprite cycle skip counter
            ldy #0                          ; init pixels in char counter


; Munch character if applicable
munch:
            lda #RASTER_LINE
.wait_rast: cmp VIC2RASTER                  ; busy wait for next raster line
            bne .wait_rast

            lda $d010                       ; sprite #0: x > 255 ?
            beq on_char                     ; sprite #0 has x > 255
            lda $d000
            cmp #320-255-1                  ; sprite #0 x out of screen (right)?
            bcs x_test                      ; then don't try to munch char

; Test if we are on a character (every PIXELS_PER_CHAR)
on_char:    iny                             ; pacman is on a char
            cpy #PIXELS_PER_CHAR            ; have we reached the next char?
            bne x_test

munch_it:   lda #MUNCHED_CHAR               ; pacman is on a new char
            ldy #0                          ; reset pixels in char counter
            sta (CURRENT_CHAR), y           ; munch the char
            lda #PIXELS_PER_CHAR
            inc CURRENT_CHAR                ; next char location low byte
            bne x_test
            inc CURRENT_CHAR + 1            ; next char location high byte

; Test on which part of the screen is sprite #0
x_test:     lda $d010                       ; sprite #0: x > 255 ?
            bne x_right                     ; sprite #0 has x > 255

; Sprite #0 on the left part of the screen (x-coord <= 255)
x_left:     nop                             ; slow things down a little: less cycles
            nop                             ; take place on the left part of screen
            inc $d000                       ; move one pixel to the right
            bne cycle_sprite                ; not reached yet end of left screen part
            inc $d010                       ; sprite #0: x bit #8 (right)
            jmp cycle_sprite

; Sprite #0 on the right part of the screen (x-coord > 255)
x_right:    inc $d000                       ; move one pixel to the right
            
            lda $d000
            cmp #10+320-255+20              ; reached right border?
            bne cycle_sprite

.right_border_reached:            
            lda #0                          ; border reached
            sta $d000                       ; sprite #0: x=0
            sta $d010                       ; sprite #0: x bit #8 (left)

            lda #7
            clc
            adc $d001                       ; sprite #0: y-coord next text line
            cmp #END_ROW
            bcs end                         ; done if reached bottom of screen
            sta $d001                       ; next text line: add 8 pixels to y

; Animate the sprite #0 by cycling through the bitmap
cycle_sprite:
            dex
            bne munch
            ldx #SPRITE_CYCLE_SKIP
            inc DEFAULT_SPRITE_PTR_AREA     ; cycle through the sprite map
            lda DEFAULT_SPRITE_PTR_AREA     ; in order to animate our pacman
            cmp #$80 + PACMAN_FRAMES - 1
            bne munch
            lda #$80
            sta DEFAULT_SPRITE_PTR_AREA     ; back to first bitmap bank
            bne munch

end:
            rts


msg:
            !fill 13, 32
            !pet "crazy pacman"
            !byte 13, 13
            !fill 11, 32
            !pet "is on  ur screen"
            !byte 13, 13
            !fill 12, 32
            !pet "eating ur text"
            !byte 0


            !src <lib/strings/strout.a>

sprite:
            !bin <programs/pacmunch/pacmunch.bin>

