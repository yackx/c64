; Soft RTL text scroll demo.
;
; This program uses the horizontal scroll of the screen control register
; to move one pixel at a time. When the maximum of 7 bits scroll
; is reached, we hard scroll by rewriting the text line, shifted
; by one character.
;
; The screen is set to 38 cols to hide the scroll motion taking place
; on the leftmost column.

        ;ACME 0.97
        !cpu 6510
        * = $c000

        ; current scroll register mask (bits #2 to #0)
        !addr ZP_SCROLL_COUNT = $02
        
        ; skip raster frames count
        !addr ZP_SKIP = $2a

        SCREEN = $0400
        TEXT_LINE = 1
        START_OF_LINE = SCREEN + 40 * TEXT_LINE
        RASTER_LINE = 100       ; outside the scrolled line
        SKIP_FRAMES = 1         ; slow down


main:
        jsr init
        jsr set_raster_irq
        jmp *                   ; wait for IRQ


init:
        lda #1                  ; will trigger hard scroll
        sta ZP_SCROLL_COUNT     ; on 1st IRQ
        
        lda #1                  ; do not skip 1st frame
        sta ZP_SKIP
        
        jsr $ff81               ; clear screen

        lda $d016               ; screen control register
        and #%11110111          ; screen 38 cols
        sta $d016

        rts


set_raster_irq:
        sei                     ; turn off interrupts

        lda #%01111111
        sta $dc0d               ; switch off interrupt signals from CIA-1
        
        and $d011
        sta $d011               ; scanline hi bit

        lda #RASTER_LINE
        sta $d012               ; set rasterline

        lda #<irq_handler       ; set raster interrupt vector
        sta $0314
        lda #>irq_handler
        sta $0315
        
        lda #%00000001          ; enable raster interrupts
        sta $d01a

        cli                     ; clear interrupt flag

        rts


irq_handler:
        ; Skip frames if applicable.
        dec ZP_SKIP
        beq +
        jmp .done

+       ; Reset skip frame counter.
        lda #SKIP_FRAMES
        sta ZP_SKIP

        ; One less pixel on the scroll.
        ; If count goes below 0, go back to 7 pixels and hardscroll.
        ; Do not hardscroll when scroll = 0, it would be too early
        ; and cause a glitch.
        dec ZP_SCROLL_COUNT
        lda ZP_SCROLL_COUNT
        bpl + 
        
        ; Wrap scroll pixel count from 0 to 7.
        ; Trigger hard scroll.
        lda #7
        sta ZP_SCROLL_COUNT
        jsr hard_scroll

+       ; Set horizontal scroll (bits #2-#0)
        lda $d016
        and #%11111000          ; masks for scr ctrl reg
        ora ZP_SCROLL_COUNT     ; set how many scroll pixels
        sta $d016

.done:
        asl $d019               ; ACK IRQ
        jmp $ea81               ; KERNAL shorter routine


; Hard scroll:
; rewrite the screen line, shift 1 character
hard_scroll:
        ; Print a text line.
        ldx #39
        !addr .msg_offset_addr = *+1
-       lda marquee,x
        beq .end_of_msg

        ; Update one character.
        ; Check for end of line.
        sta START_OF_LINE,x 
        dex
        bpl -

        inc .msg_offset_addr    ; next msg is offset by 1 char
        rts

.end_of_msg:
        ; End of message.
        ; Reset msg offset and bail out.
        lda #<marquee
        sta .msg_offset_addr
        rts


        !align $ff, 0, 0
marquee:
        !fill 40, $20
        !scr "this is a scrolling text - soft scroll - "
        !scr "rtl (right-to-left) - "
        !scr "using raster interrupt - "
        !scr "one pixel at a time."
        !byte 0
